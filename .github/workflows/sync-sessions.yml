# ============================================================================
# üîÑ Sync sessions + root README from private repos-teachers ‚Üí repos-students
#    (via Deploy Key)
#
# Objectiu:
# - Des d‚Äôun repo privat de profes (source) copia:
#   - README.md de l‚Äôarrel (opcional)
#   - Per a cada carpeta 'sessionNN' oberta, el README.md i la subcarpeta 'starter/'
# - Les sessions ‚Äúobertes‚Äù venen definides al fitxer configurat per la variable
#   OPEN_SESSIONS_FILE (p. ex. "_course/open-sessions.txt") ‚Äî AL REPO D‚ÄôORIGEN.
# ============================================================================

name: üîÑ Sync sessions + root README from private repos-teachers ‚Üí repos-students (Deploy Key)

on:
  schedule:
    - cron: '0 * * * *' # cada hora
  workflow_dispatch: {}

permissions:
  contents: write

env:
  # --- Source (repo de profes, privat) --------------------------------------
  SOURCE_ORG: 'LSG-markup-lang'
  SOURCE_REPO: 'demos'
  SOURCE_BRANCH: 'main'

  # --- Auth (Deploy Key via secret) -----------------------------------------
  SOURCE_DEPLOY_KEY_SECRET: 'SOURCE_DEPLOY_KEY'

  # --- Target (repo d‚Äôalumnes) ----------------------------------------------
  TARGET_BRANCH: 'main'

  # --- Qu√® copiar del source ------------------------------------------------
  COPY_ROOT_README: 'true'
  SESSION_PATTERN: 'session[0-9][0-9]'
  STARTER_DIRNAME: 'starter'

  # --- Fitxer amb la llista de sessions obertes (AL REPO D'ORIGEN) ----------
  OPEN_SESSIONS_FILE: '_course/open-sessions.txt'

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: ‚¨áÔ∏è Checkout target (${{ github.repository }} @ ${{ env.TARGET_BRANCH }})
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.TARGET_BRANCH }}

      - name: üîê Setup SSH for private source (Deploy Key)
        env:
          SOURCE_DEPLOY_KEY: ${{ secrets[env.SOURCE_DEPLOY_KEY_SECRET] }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "$SOURCE_DEPLOY_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: ‚¨áÔ∏è Clone private source repo (${{ env.SOURCE_ORG }}/${{ env.SOURCE_REPO }} @ ${{ env.SOURCE_BRANCH }})
        run: |
          set -euo pipefail
          git clone --depth=1 --branch "${SOURCE_BRANCH}" "git@github.com:${SOURCE_ORG}/${SOURCE_REPO}.git" source

      # ----------------------------------------------------------------------
      # üö¶ 4) Calcula sessions a sincronitzar (intersecci√≥ OPEN √ó SOURCE)
      #     Llegeix l‚Äô"open-sessions.txt" des de **source/**.
      # ----------------------------------------------------------------------
      - name: üö¶ Build allowlist from ${{ env.OPEN_SESSIONS_FILE }} ‚à© source
        id: allow
        shell: bash
        run: |
          set -euo pipefail

          OPEN_FILE="source/${OPEN_SESSIONS_FILE}"

          # 1) Llegeix sessions obertes tolerant comentaris/espais/CRLF
          OPEN_SESS=()
          if [[ -f "$OPEN_FILE" ]]; then
            mapfile -t OPEN_SESS < <(
              sed -E 's/#.*$//' "$OPEN_FILE" |   # treu comentaris finals
              tr -d '\r' |                       # treu CR (Windows)
              grep -Eo 'session[0-9]{2}' || true # extreu tokens v√†lids
            )
          else
            echo "‚ö†Ô∏è No s'ha trobat $OPEN_FILE ‚Üí cap sessi√≥ oberta."
          fi

          # Normalitza i treu duplicats
          if (( ${#OPEN_SESS[@]} > 0 )); then
            mapfile -t OPEN_SESS < <(printf "%s\n" "${OPEN_SESS[@]}" | awk 'length>0' | sort -u)
          fi
          echo "OPEN_SESS: ${OPEN_SESS[*]:-‚àÖ}"

          # 2) Llista de sessions existents al repo font
          SRC_SESS=()
          mapfile -t SRC_SESS < <(cd source && find . -maxdepth 1 -mindepth 1 -type d -name "${SESSION_PATTERN}" -printf '%f\n' 2>/dev/null | sort -u || true)
          echo "SRC_SESS:  ${SRC_SESS[*]:-‚àÖ}"

          # 3) Intersecci√≥: nom√©s les que s√≥n a OPEN i existeixen a source
          declare -A SEEN=()
          if (( ${#SRC_SESS[@]} > 0 )); then
            for s in "${SRC_SESS[@]}"; do
              [[ -n "${s:-}" ]] || continue
              SEEN["$s"]=1
            done
          fi

          ALLOW=()
          if (( ${#OPEN_SESS[@]} > 0 )); then
            for s in "${OPEN_SESS[@]}"; do
              [[ -n "${s:-}" ]] || continue
              if [[ -n "${SEEN[$s]:-}" ]]; then
                ALLOW+=("$s")
              else
                echo "‚ÑπÔ∏è  Ometo ${s}: no existeix al repo font."
              fi
            done
          fi

          # 4) Exporta la llista (separada per espais) com a output
          if (( ${#ALLOW[@]} > 0 )); then
            SESSIONS="$(printf "%s " "${ALLOW[@]}")"
            echo "allow_sessions=${SESSIONS}" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Sessions a sync: ${SESSIONS}"
          else
            echo "allow_sessions=" >> "$GITHUB_OUTPUT"
            echo "‚úÖ No hi ha sessions per sincronitzar."
          fi

      - name: üîé Detect sessions to sync
        id: pick
        shell: bash
        run: |
          set -euo pipefail
          echo "sessions=${{ steps.allow.outputs.allow_sessions }}" >> "$GITHUB_OUTPUT"

      # ----------------------------------------------------------------------
      # üßπ 6) Purge al repo d'alumnes: esborra les sessions no obertes
      # ----------------------------------------------------------------------
      - name: üßπ Purge closed sessions from target
        shell: bash
        run: |
          set -euo pipefail

          declare -A ALLOWED=()
          for s in ${{ steps.pick.outputs.sessions }}; do
            [[ -n "${s:-}" ]] && ALLOWED["$s"]=1
          done

          mapfile -t EXIST < <(find . -maxdepth 1 -mindepth 1 -type d -name "${SESSION_PATTERN}" -printf '%f\n' 2>/dev/null | sort -u || true)

          REMOVED=0
          KEPT=0
          for d in "${EXIST[@]:-}"; do
            [[ -n "${d:-}" ]] || continue
            if [[ -z "${ALLOWED[$d]:-}" ]]; then
              echo "üßπ Remove closed session $d"
              rm -rf "$d"
              REMOVED=$((REMOVED+1))
            else
              echo "‚úÖ Keep open session $d"
              KEPT=$((KEPT+1))
            fi
          done

          echo "Summary purge: kept=$KEPT removed=$REMOVED"

      - name: üß© Copy sessions and root README.md
        if: ${{ steps.pick.outputs.sessions != '' }}
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${COPY_ROOT_README}" == "true" && -f "source/README.md" ]]; then
            echo "‚Üí Syncing root README.md"
            cp -f "source/README.md" README.md
          fi

          for S in ${{ steps.pick.outputs.sessions }}; do
            [[ -d "source/$S" ]] || continue
            echo "‚Üí Sync $S"

            mkdir -p "$S"

            if [[ -f "source/$S/README.md" ]]; then
              cp -f "source/$S/README.md" "$S/README.md"
            fi

            if [[ -d "source/$S/${STARTER_DIRNAME}" ]]; then
              rm -rf "$S/${STARTER_DIRNAME}"
              rsync -a --delete "source/$S/${STARTER_DIRNAME}/" "$S/${STARTER_DIRNAME}/"
            fi
          done

      - name: ‚úÖ Commit & push changes (if any)
        env:
          COMMIT_SESSIONS: ${{ steps.pick.outputs.sessions }}
        run: |
          set -euo pipefail
          rm -rf source

          if [ -n "$(git status --porcelain)" ]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "chore(sync): purge closed + update root README and ${COMMIT_SESSIONS} from ${SOURCE_ORG}/${SOURCE_REPO} [skip ci]"
            git push origin "HEAD:${TARGET_BRANCH}"
          else
            echo "‚úÖ No changes."
          fi
